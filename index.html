<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureVault – A Zero-Knowledge Password Manager with Blockchain-Anchored Integrity</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }
        h1 {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 10px;
        }
        .authors {
            text-align: center;
            font-style: italic;
            margin-bottom: 30px;
        }
        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        .abstract {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }
        .index-terms {
            font-style: italic;
            margin: 15px 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        .reference {
            margin: 10px 0;
            padding-left: 20px;
            text-indent: -20px;
        }
        code {
            background-color: #f1f2f6;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>SecureVault – A Zero-Knowledge Password Manager with Blockchain-Anchored Integrity</h1>
    
    <div class="authors">
        <strong>Given Name Surname</strong><br>
        dept. name of organization<br>
        name of organization<br>
        City, Country<br>
        email address
    </div>

    <div class="abstract">
        <h2>Abstract</h2>
        <p>In the modern digital era, most services and transactions are conducted online across various commercial sectors. Password-based systems are widely used to ensure data confidentiality and are available only to authorized users. However, traditional models typically perform data encryption on the server side, which makes user data vulnerable if the server is compromised.</p>
        
        <p>Therefore, this paper presents a next-generation password manager, SecureVault, that implements a zero-knowledge security model with client-side encryption and blockchain-based integrity verification. Passwords are encrypted in the browser (client-side) using AES-256-GCM with keys derived through PBKDF2 (310k iterations), ensuring that the plaintext secrets and master key never leave the client. The server stores only ciphertext and metadata, and a smart contract records hashes and timestamps to provide tamper-evident integrity without exposing user data.</p>
        
        <p>Some existing client-side encryption systems lack tamper-evident integrity verification. If the server is compromised, encrypted data could be corrupted or silently deleted and is also vulnerable to undetected server rollback. Whereas, fully blockchain-based password managers store encrypted data on-chain, creating privacy and cost concerns. Therefore, in SecureVault, we use blockchain only for integrity anchoring by storing only hashes. This results in strong confidentiality with verifiable integrity without having a single point of trust.</p>
        
        <p class="index-terms"><strong>Index Terms—</strong> Zero-Knowledge architecture, client-side encryption, Password Manager, Blockchain, Security.</p>
    </div>

    <h2>I. INTRODUCTION</h2>
    <p>Passwords are the most common and widely used form of authentication. Although companies and websites are spreading awareness to let users know about the risks of weak and reused passwords, users still reuse credentials across sites of unequal importance, turning one breach into multi-site compromise via credential stuffing [1]. People usually use the same credentials across sites or do not remember strong and unique passwords. Existing password managers solve this problem of remembering passwords, but users have to trust the server with their data. Even leading and modern zero-knowledge password managers, including Bitwarden and 1Password, derive keys client-side and do not store any plaintext on the server, but they do not provide a public, provider-independent way to detect silent rollback, deletion, or reordering of ciphertexts [2], [3].</p>

    <p>The LastPass breach of 2022 exposed this weakness clearly: although vaults were encrypted, post-breach uncertainty and provider-controlled recovery left users without any cryptographic mechanism to verify whether their encrypted state had been altered or reverted [4]. This incident highlighted a fundamental gap in current password management architectures: while confidentiality can be achieved through client-side encryption, without an independent way to verify the integrity of the data, users must trust the provider's database as the only source of truth.</p>

    <p>We propose SecureVault—a password manager that eliminates the single point of failure that plagues traditional password managers while providing verifiable integrity without requiring users to trust a central server. Unlike existing systems that encrypt data server-side (making them vulnerable to complete data exposure if the server is compromised) or lack tamper-evident integrity verification (leaving users unable to detect server rollback or silent deletion), SecureVault implements zero-knowledge architecture with client-side encryption/decryption and blockchain-anchored integrity.</p>

    <p>In our implementation, all cryptographic operations (encryption and decryption) happen in the browser, with the master key never leaving the device. We use PBKDF2 (HMAC-SHA256, 310k) to derive the key, and AES-256-GCM per item with a unique IV to avoid nonce reuse as per NIST guidance [5]. Whenever there is any change to the vault, the client creates a single summary hash (a Merkle root) of the encrypted data and saves only that hash on the blockchain. Later, when the user loads the vault, the client recalculates the hash and checks it against the on-chain value. If they match, then nothing was tampered with; otherwise, the data is compromised. This approach lets us prove integrity without putting any sensitive data on-chain, avoiding extra costs and privacy leaks, and it removes the need to fully trust a single server for the integrity of the data.</p>

    <h2>II. LITERATURE SURVEY</h2>
    <p>The existing password managers can be categorized into three main categories: centralized zero-knowledge (ZK) password managers (e.g., Bitwarden, 1Password), Centralized non–zero-knowledge password managers (e.g., Google Password Manager) and Blockchain-based (decentralized) password managers (e.g., PassChain)</p>

    <h3>Centralized Zero-Knowledge Systems</h3>
    <p>Like Bitwarden and 1Password are widely used Zero-Knowledge designs. Bitwarden's security white paper [2] describes client-side key derivation (PBKDF2) with server storing only ciphertexts; but still users have to trust the provider for integrity of their data and cannot verify server-side rollback, deletion and reordering of data. 1Password uses SRP (Secure Remote Password) and end-to-end encryption [3] but like other systems it also lacks public, provider-independent integrity of the vault.</p>

    <p>Horcrux [6] partitions user's vault across several servers so that no single server had the complete data of users. This makes attacks harder, but it also makes the system complicated to run. It needs trusted middle services and careful syncing between pieces. But, because of that extra complexity, it is unsuitable for the majority of the general users.</p>

    <h3>Centralized Non–Zero-Knowledge password managers</h3>
    <p>Like Google Password Manager is neither zero-knowledge nor blockchain-based. Since provider manages the keys and backend, it makes sync and account recovery easy, but it also means users have to trust the provider. Google can see the metadata and controls the retention of the data. There is no public, cryptographic proof to detect silent rollback or tampering. So in this type of architecture, user get convenience like easy sync, but user have to trust the provider completely.</p>

    <h3>Blockchain-Based Systems</h3>
    <p>Like PassChain [7] store encrypted data or their hashes directly on-chain. It increases costs (gas per item) and risks exposing metadata. Panchal et al. [8] also use the blockchain as a storage layer. This design is transparent but it does not scale in reality because of privacy exposure and gas costs. LogStamping [9] anchors only commitment (e.g., Merkle roots) instead of raw data, With this LogStamping achieves tamper-evident auditing with much lower cost and better privacy. We use this "commitment, not data" pattern in our password vaults, where client keeps all the encryption client-side and publish only a Merkle root for integrity verification.</p>

    <p>There are some <strong>Zero-Stored-Secret and Multi-Factor Approaches</strong> like MFDPG [10] that avoids keeping a long-term secret on the server by using MFA tied to the current session. But user still have to trust the server to stay consistent, and there is no public way to prove the data wasn't rolled back or changed.</p>

    <p><strong>Trust and transparency studies</strong> like Alodhyani et al. [11] finds out that people are more likely to use password managers whose design is transparent. The LastPass breach analysis [4] highlights that encryption alone does not prevent undetected rollback or corruption.</p>

    <p>From this survey, we identified three critical gaps in existing password managers: First, Zero-Knowledge managers (e.g., Bitwarden/1Password) lack cryptographic and public integrity verification (rollback/tamper evidence). Second, Blockchain-first password managers compromise privacy and increase costs by storing data or hashes on-chain. And third, Mainstream password managers like Google Password Manager optimize usability but are neither Zero-Knowledge nor verifiable on a public ledger.</p>

    <p>SecureVault bridges these gaps by doing all encryption in the browser and anchoring only a Merkle root to the blockchain. Data stays private (zero-knowledge), and any rollback or tampering shows up, while the system remains practical to use.</p>

    <h2>III. METHODOLOGY</h2>
    
    <h3>A. System Architecture</h3>
    <p>SecureVault employs a four-tier architecture designed to eliminate single points of failure while maintaining zero-knowledge principles. The system consists of:</p>
    
    <ul>
        <li><strong>Client (Browser/Application)</strong>: Handles all cryptographic operations using the Web Crypto API. The master key never leaves the device, ensuring complete client-side control over sensitive data. Keys are derived using PBKDF2-HMAC-SHA256 with 310,000 iterations, and each credential is encrypted with AES-256-GCM using unique 12-byte initialization vectors. Only ciphertext, IV, salt, and metadata are transmitted to the server.</li>
        
        <li><strong>Server (Cloud Backend)</strong>: Built on Node.js/Express, this component manages user authentication, input validation, optional breach monitoring, and CRUD operations for encrypted credentials. Crucially, the server never handles plaintext data or master keys. After any vault modification, it updates the Merkle root and submits the new hash to the blockchain.</li>
        
        <li><strong>Database (MongoDB)</strong>: Stores exclusively encrypted data and metadata—no plaintext or master keys ever enter the database. This design ensures that even complete database compromise cannot expose user secrets.</li>
        
        <li><strong>Blockchain Network (Ethereum Sepolia)</strong>: A minimal smart contract maintains the latest Merkle root for each user account and emits verification events. This provides tamper-evident integrity without storing sensitive data on-chain.</li>
    </ul>

    <p>The data flow follows a zero-trust model: encryption occurs client-side, only encrypted data traverses the network, and integrity verification happens through blockchain anchoring.</p>

    <h3>B. Client-Side Encryption Process</h3>
    <p>Our encryption mechanism prioritizes security through multiple layers of protection:</p>
    
    <p><strong>Key Derivation</strong>: We use PBKDF2-HMAC-SHA256 with 310,000 iterations and a 16-byte random salt generated via <code>crypto.getRandomValues()</code>. This high iteration count significantly slows down offline brute-force attacks while remaining practical for modern devices.</p>
    
    <p><strong>Encryption Algorithm</strong>: AES-256-GCM provides authenticated encryption, ensuring both confidentiality and integrity. Each credential receives a fresh 12-byte IV to prevent nonce reuse attacks. The GCM mode includes built-in authentication, so any ciphertext modification results in decryption failure.</p>
    
    <p><strong>Process Flow</strong>:</p>
    <ol>
        <li>User enters master password</li>
        <li>Generate random salt using <code>crypto.getRandomValues()</code></li>
        <li>Derive encryption key via PBKDF2-HMAC-SHA256 (310k iterations)</li>
        <li>For each credential, generate unique 12-byte IV</li>
        <li>Encrypt password with AES-256-GCM</li>
        <li>Transmit only {ciphertext, IV, salt, metadata} to server</li>
    </ol>

    <p>We chose AES-GCM over other modes because it provides authenticated encryption in a single pass, reducing computational overhead while maintaining strong security guarantees.</p>

    <h3>C. Key Management and Authentication</h3>
    <p>Authentication operates on a zero-knowledge principle where the master key never leaves the client device:</p>
    
    <p><strong>Session Management</strong>: The master key exists only in browser sessionStorage and is automatically destroyed when the session ends. This ensures that server compromise cannot expose user credentials.</p>
    
    <p><strong>Biometric Integration</strong>: WebAuthn provides phishing-resistant authentication through platform authenticators, allowing users to unlock their vault without repeatedly entering the master password. The biometric authentication operates locally and never transmits biometric data to the server.</p>
    
    <p><strong>JWT Token Security</strong>: API calls are protected using JWT tokens that contain no sensitive information. The tokens are used solely for session management and API authorization.</p>
    
    <p><strong>Key Derivation Security</strong>: Each user session generates a unique salt, preventing rainbow table attacks even if the database is compromised. The high iteration count (310,000) makes offline attacks computationally expensive.</p>

    <h3>D. Server-Side Data Handling</h3>
    <p>The server operates as a minimal, stateless component that never handles sensitive data:</p>
    
    <p><strong>Data Storage</strong>: The server stores only encrypted vault data (ciphertext), metadata (vault ID, hash, timestamp), and user account information. No plaintext passwords or master keys ever reach the server.</p>
    
    <p><strong>Zero-Knowledge Property</strong>: The server cannot decrypt or read any user data, even with complete administrative access. This eliminates the risk of insider threats and server-side data breaches.</p>
    
    <p><strong>Stateless Design</strong>: The server maintains minimal state, with all sensitive operations handled client-side. This reduces the attack surface and simplifies security auditing.</p>
    
    <p><strong>API Security</strong>: All endpoints include CORS protection, rate limiting, and input validation. The server acts as a secure conduit for encrypted data without ever having access to the plaintext.</p>

    <h3>E. Blockchain Anchoring for Integrity Verification</h3>
    <p>Blockchain integration provides tamper-evident verification without compromising privacy:</p>
    
    <p><strong>Hash Computation</strong>: When users modify their vault, the client computes a SHA-256 hash of the encrypted data structure and builds a Merkle tree. Only the Merkle root is stored on-chain, not the actual encrypted data.</p>
    
    <p><strong>Smart Contract Functions</strong>:</p>
    <ul>
        <li><code>updateVaultHash(userId, root)</code>: Records the latest vault hash with timestamp</li>
        <li><code>getVaultHash(userId)</code>: Retrieves the current hash for verification</li>
        <li>Event emission enables public verification of updates</li>
    </ul>
    
    <p><strong>Privacy Preservation</strong>: Only hash values are stored on-chain, maintaining user privacy while providing cryptographic proof of data integrity. This approach avoids the privacy and cost concerns of storing encrypted data directly on-chain.</p>
    
    <p><strong>Tamper Detection</strong>: Any unauthorized modification, rollback, or deletion of encrypted data will result in a hash mismatch during verification, immediately alerting users to potential compromise.</p>

    <h3>F. Data Retrieval and Decryption</h3>
    <p>The decryption process includes integrity verification before any data access:</p>
    
    <p><strong>Data Download</strong>: Encrypted vault data is retrieved from the server along with associated metadata.</p>
    
    <p><strong>Integrity Verification</strong>: The client recomputes the Merkle root from the downloaded data and compares it against the blockchain-stored hash. Only if the hashes match does the system proceed with decryption.</p>
    
    <p><strong>Local Decryption</strong>: If integrity verification passes, the client decrypts the data using the locally derived key. The master key never leaves the device during this process.</p>
    
    <p><strong>Mismatch Handling</strong>: If hash verification fails, the system alerts the user to potential data corruption or unauthorized modification. This prevents silent data compromise and provides cryptographic proof of tampering.</p>
    
    <p><strong>Backup and Recovery</strong>: Users can export encrypted backups for offline storage, maintaining the zero-knowledge property while providing data portability.</p>

    <p>This methodology ensures that users maintain complete control over their data while having cryptographic proof of its integrity, eliminating the need to trust any single server or provider.</p>

    <h2>IV. EVALUATION AND RESULTS</h2>
    <p>In this section, we will now discuss the proposed system's end-to-end flow and functionality.</p>

    <p>a) <strong>Signup</strong>: The user creates an account using email and a master key. The master key is stored only in the sessionStorage and never sent to the server.</p>

    <p>b) <strong>Add credential (client-side encryption)</strong>: Before saving, the browser derives a key via PBKDF2-HMAC-SHA256 and encrypts the password with AES-256-GCM using a fresh 12-byte IV. Then, only ciphertext, IV, salt, and metadata are sent to the server. No plaintext or keys traverse the network.</p>

    <p>c) <strong>Vault list (local decrypt and actions)</strong>: All the saved entries will be displayed. Users will be able to interact with a set of actions, such as search and reveal/copy. Reveal/copy decrypts the data on the client side only, the server never handles or have access to the plaintext.</p>

    <p>d) <strong>Security monitor (breach check)</strong>: The app uses HaveIBeenPwned API to check for breach, flag exposed credentials, and prompts the user to change them.</p>

    <p>e) <strong>In-app integrity status</strong>: All integrity updates and a link to the contract/updates are shown so that the users can verify them on the blockchain explorer using the link.</p>

    <p>f) <strong>Public audit proof (explorer)</strong>: A public block-explorer page confirms that the latest vault summary was recorded and is verifiable by anyone.</p>

    <p>g) <strong>Server storage view (database)</strong>: The database stores only the encrypted password, iv, salt, and metadata along with userId—no plaintext or master key is ever stored or leaves the client.</p>

    <h2>V. SECURITY ANALYSIS</h2>

    <h3>A. Confidentiality</h3>
    <p>All passwords are encrypted and decrypted within the browser, and the master key never leaves the device. The server only stores ciphertext and metadata.</p>

    <h3>B. Integrity</h3>
    <p>Vault state hashes are anchored via smart contract on the blockchain, which allows for the detection of tampering or rollback.</p>

    <h3>C. Availability</h3>
    <p>The encrypted vault is stored in the database. User can access it from any device and user can also import and export a local backup.</p>

    <h3>D. Threat Model</h3>
    <p>SecureVault addresses the following threats:</p>
    <ul>
        <li><strong>Server Compromise</strong>: Attacker gains only ciphertext, and no access to plaintext data.</li>
        <li><strong>Data Tampering</strong>: Detected via blockchain Merkle root verification.</li>
        <li><strong>Replay Attacks</strong>: Prevented through unique IVs and timestamp validation.</li>
        <li><strong>Phishing</strong>: Mitigated through WebAuthn origin binding.</li>
        <li><strong>Key Loss</strong>: Addressed through backup codes and recovery mechanisms.</li>
        <li><strong>Metadata Leakage</strong>: Minimized through blockchain-only Merkle root storage.</li>
    </ul>

    <h2>VI. CONCLUSION</h2>
    <p>SecureVault is a password manager that significantly advances password management by integrating zero-knowledge encryption with blockchain-anchored integrity verification. Our approach introduces two key innovations. First, SecureVault achieves both confidentiality through its Zero-Knowledge architecture and verifiable integrity by committing only a Merkle root of the encrypted vault on a public blockchain. Second, we provide the first practical implementation of a password manager that eliminates the single point of trust that users must place in current architectures. Our system ensures that even if the server is compromised, attackers cannot silently modify or rollback user data without detection—addressing the major limitations exposed by incidents like the LastPass breach, where encrypted data remained vulnerable to undetected manipulation.</p>

    <h2>REFERENCES</h2>
    
    <div class="reference">[1] A. Mathews and S. M. T. Haque, "Exploring the risks of password reuse across websites of different importance," in Human Interaction and Emerging Technologies (IHIET 2024), New York, USA: AHFE Open Access, 2024, ISBN: 978-1-964867-33-5. DOI: 10.54941/ahfe1005469. [Online]. Available: https://openaccess.cms-conferences.org/publications/book/978-1-964867-33-5/article/978-1-964867-33-5_11.</div>

    <div class="reference">[2] Bitwarden Inc., Bitwarden security white paper, White paper, 2025. Accessed: Oct. 15, 2025. [Online]. Available: https://bitwarden.com/security/white-paper/.</div>

    <div class="reference">[3] AgileBits Inc., 1password security design white paper, White paper, 2025. Accessed: Oct. 15, 2025. [Online]. Available: https://1password.com/security/white-paper/.</div>

    <div class="reference">[4] J. Gentles, M. Fields, G. Goodman, and S. Bhunia, Breaking the vault: A case study of the 2022 lastpass data breach, 2025. arXiv: 2502.04287 [cs.CR]. [Online]. Available: https://arxiv.org/abs/2502.04287.</div>

    <div class="reference">[5] M. Dworkin, "Recommendation for block cipher modes of operation: Galois/counter mode (gcm) and gmac," National Institute of Standards and Technology, Tech. Rep. NIST SP 800-38D, Nov. 2007. [Online]. Available: https://doi.org/10.6028/NIST.SP.800-38D.</div>

    <div class="reference">[6] H. Li and D. Evans, "Horcrux: A password manager for paranoids," arXiv, 2017. DOI: 10.48550/arXiv.1706.05085. arXiv: 1706.05085 [cs.CR]. [Online]. Available: https://arxiv.org/abs/1706.05085.</div>

    <div class="reference">[7] N. A. Chowdhury Anik et al., "Passchain: A blockchain-based decentralized password manager," in 2024 IEEE International Conference on Blockchain and Distributed Systems Security (ICBDS), 2024, pp. 1–6. DOI: 10.1109/ICBDS61829.2024.10837098.</div>

    <div class="reference">[8] R. Panchal, S. Sharma, A. Negi, A. Arora, and I. Gupta, "Secure and transparent password storing mechanism using blockchain," International Journal of Engineering in Computer Science, vol. 3, pp. 33–40, Jul. 2021. DOI: 10.33545/26633582.2021.v3.i2a.66.</div>

    <div class="reference">[9] M. S. Islam and M. S. Rahman, Logstamping: A blockchain-based log auditing approach for large-scale systems, 2025. arXiv: 2505.17236 [cs.CR]. [Online]. Available: https://arxiv.org/abs/2505.17236.</div>

    <div class="reference">[10] V. Nair and D. Song, Mfdpg: Multi-factor authenticated password management with zero stored secrets, 2023. arXiv: 2306.14746 [cs.CR]. [Online]. Available: https://arxiv.org/abs/2306.14746.</div>

    <div class="reference">[11] F. Alodhyani, G. Theodorakopoulos, and P. Reinecke, "Password managers—it's all about trust and transparency," Future Internet, vol. 12, no. 11, 2020, ISSN: 1999-5903. DOI: 10.3390/fi12110189. [Online]. Available: https://www.mdpi.com/1999-5903/12/11/189.</div>

    <div class="reference">[12] E. Barker, "Recommendation for password-based key derivation: Part 1: Using pbkdf2," National Institute of Standards and Technology, Tech. Rep. NIST SP 800-132, Dec. 2010. [Online]. Available: https://doi.org/10.6028/NIST.SP.800-132.</div>

</body>
</html>
